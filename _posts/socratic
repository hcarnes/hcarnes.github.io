#Ruby on Rails Q & A App

Keeping track of how things are supposed to work at work is hard. Nobody likes getting asked the same question over and over, especially ones that probably have answers buried in Slack or old emails. I created Socratic to solve this problem. This app allows users to post questions, allows multiple users to answer one question, and allows users to mark the most helpful answer with a green check mark.

One of the biggest hurdles I faced during this project was meeting the following requirement: You must include a nested form that writes to an associated model through a custom attribute writer.

A nested form handles more than one model object at a time. With nested forms, users can submit one form, as opposed to a new form for each model object. In my case, I used a nested form that allows users to submit a question and associated tags on the same form. 

## Setting Up Object Relationshps

Because questions can have multiple tags and tags can belong to multiple questions, I created the join table, QuestionTags. You can see how I mapped this `has_many :through`, along with all the other relationshpips here. Next, I nested the `tag_name` attribute in question form:

## Creating a Nest Form

```ruby
<%= form_for @question do |f| %>
  <%= f.label :summary %>
  <%= f.text_field :summary %>

  <%= f.label :tag_names, "Tags" %>
  <%= f.text_field :tag_names, class: "form-control" %>

  <%= f.label :content, "Question" %>
  <%= f.text_area :content %>
  <%= f.submit class:  %>
<% end %>
```
## Updating Strong Params

I also added the new custom associated attribute to the permitted params in the `QuestionsController`. Now, our newly created attribute is on the model's whitelist of accepted attributes, so we won't get an errors telling us that our new attribute isn't allowed.

```ruby
class QuestionsController < ApplicationController
  ...
  private

  def permitted_question_params
    params.require(:question).permit(:content, :summary, :tag_names)
  end
end
```
## Attribute Customization

I had to also create the association in the parent model. In this case, I created readers and writers for `tag_names` in the Question model.

```ruby
class Question < ApplicationRecord
  has_many :question_tags
  has_many :tags, through: :question_tags

  validates_presence_of :content, message: "Empty questions are not virtuous"
  validates_presence_of :summary, message: "Brevity is the soul of wit, so summary is required"

  def tag_names
    self.tags.map(&:name).join(", ")
  end

  def tag_names=(names)
    self.tags = names.split(",").map(&:strip).map do |name|
      Tag.find_or_initialize_by(name: name)
    end
  end
end
```
The form looks simple, but as you can see, there is a lot going on behind the scenes.

[Imgur](https://i.imgur.com/xip4utG.png)



